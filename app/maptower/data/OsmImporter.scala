package maptower.data

import scala.xml.pull._
import scala.io.Source
import java.io.File
import com.mongodb.casbah.commons.{ MongoDBObject => Obj, MongoDBList => ObjList }
import com.mongodb.casbah.Imports._
import maptower.map.osm._

object OsmImporter {
  def load(osmDao: OsmDao, filename: String) {
    val src = Source.fromFile(new File(filename))
    val er = new XMLEventReader(src)

    var numRecordsProcessed = 0;

    var current = Obj.newBuilder
    var tags = ObjList.newBuilder
    var otherColl = ObjList.newBuilder

    while (er.hasNext) {
      er.next match {
        case comment: EvComment => println(comment.text)
        case elem: EvElemStart => {
          val attrs = elem.attrs.asAttrMap
          if (elem.label == "node" || elem.label == "way" || elem.label == "relation") {
            current = Obj.newBuilder
            current += ("osmId" -> attrs("id").toInt)
          }
          elem.label match {
            case "node" => current += ("loc" -> ObjList(attrs("lon").toFloat, attrs("lat").toFloat))
            case "tag" => tags += Obj("k" -> attrs("k"), "v" -> attrs("v"))
            case "nd" => otherColl += attrs("ref").toInt
            case "member" => otherColl += Obj("type" -> attrs("type"), "ref" -> attrs("ref").toInt, "role" -> attrs("role"))

            case "osm" => println("Processing OSM v" + attrs("version") + " generated by " + attrs("generator") + ".")
            case "bound" => println("Importing bounds box: " + attrs("box") + ".")

            case _ =>
          }
        }
        case elem: EvElemEnd => {
          var shouldPersist = false
          elem.label match {
            case "node" => {
              shouldPersist = true
            }
            case "way" => {
              current += "nodes" -> otherColl.result
              otherColl = ObjList.newBuilder
              shouldPersist = true
            }
            case "relation" => {
              current += "members" -> otherColl.result
              otherColl = ObjList.newBuilder
              shouldPersist = true
            }
            case "osm" => println("Finished processing " + numRecordsProcessed + " records.")
            case _ =>
          }
          if (shouldPersist) {
            numRecordsProcessed += 1
            current += "tags" -> tags.result
            tags = ObjList.newBuilder
            osmDao.mongoDb("osm" + elem.label).insert(current.result)
          }
        }
        case _ =>
      }
    }
  }

  def convert(osmDao: OsmDao, mapDao: MapDao) {
    val osmNodes = osmDao.mongoDb("osmnode").find(Obj("tags.k" -> "name")) map (OsmNode(_))
    val nodes = osmNodes map { _.asNode }

    val nodeCollection = mapDao.mongoDb("node")
    nodeCollection.drop
    var nodeCount = 0
    for (node <- nodes) {
      if (node.category == "unknown") {
        println(node)
      } else {
        nodeCollection.insert(node.toObj)
        nodeCount += 1
      }
    }
    println("Inserted %s nodes." format nodeCount)

    val wayCollection = mapDao.mongoDb("way")
    var wayCount = 0
    val osmWays = osmDao.mongoDb("osmway") find () map (OsmWay(_))
    val ways = osmWays map { osmWay =>
      val referencedPoints = osmDao.getNodes(osmWay.nodeIds).toSeq
      val way = osmWay.asWay(referencedPoints)
      wayCount += 1
      way
    }
    for (way <- ways) { wayCollection.insert(way.toObj) }
    println("Inserted %s ways." format wayCount)

    var relationCount = 0
    val osmRelations = osmDao.mongoDb("osmrelation") find () map (OsmRelation(_))
    for (relation <- osmRelations) {
      relationCount += 1
      println(relation.members.size, relation.tags)
    }
    println("Processed %s relations." format relationCount)
  }
}